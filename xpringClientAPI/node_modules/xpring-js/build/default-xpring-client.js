"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const xpring_common_js_1 = require("xpring-common-js");
const big_integer_1 = __importDefault(require("big-integer"));
const transaction_status_1 = __importDefault(require("./transaction-status"));
const grpc_network_client_1 = __importDefault(require("./grpc-network-client"));
const grpc_network_client_web_1 = __importDefault(require("./grpc-network-client.web"));
const amount_pb_1 = require("./generated/web/rpc/v1/amount_pb");
const utils_1 = __importDefault(require("./utils"));
const transaction_pb_1 = require("./generated/web/rpc/v1/transaction_pb");
// TODO(keefertaylor): Re-enable this rule when this class is fully implemented.
/* eslint-disable @typescript-eslint/require-await */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable class-methods-use-this */
/** A margin to pad the current ledger sequence with when submitting transactions. */
const maxLedgerVersionOffset = 10;
/**
 * Error messages from XpringClient.
 */
class XpringClientErrorMessages {
}
exports.XpringClientErrorMessages = XpringClientErrorMessages;
XpringClientErrorMessages.malformedResponse = 'Malformed Response.';
XpringClientErrorMessages.signingFailure = 'Unable to sign the transaction';
XpringClientErrorMessages.unimplemented = 'Unimplemented.';
/* eslint-disable @typescript-eslint/indent */
XpringClientErrorMessages.xAddressRequired = 'Please use the X-Address format. See: https://xrpaddress.info/.';
/**
 * A private wrapper class which conforms `GetTxResponse` to the `RawTransaction` interface.
 */
class GetTxResponseWrapper {
    constructor(getTxResponse) {
        this.getTxResponse = getTxResponse;
    }
    getValidated() {
        return this.getTxResponse.getValidated();
    }
    getTransactionStatusCode() {
        const meta = this.getTxResponse.getMeta();
        if (!meta) {
            throw new Error(XpringClientErrorMessages.malformedResponse);
        }
        const transactionResult = meta.getTransactionResult();
        if (!transactionResult) {
            throw new Error(XpringClientErrorMessages.malformedResponse);
        }
        return transactionResult.getResult();
    }
    getLastLedgerSequence() {
        const transaction = this.getTxResponse.getTransaction();
        if (!transaction) {
            throw new Error(XpringClientErrorMessages.malformedResponse);
        }
        return transaction.getLastLedgerSequence();
    }
}
/**
 * DefaultXpringClient is a client which interacts with the Xpring platform.
 */
class DefaultXpringClient {
    /**
     * Create a new DefaultXpringClient with a custom network client implementation.
     *
     * In general, clients should prefer to call `xpringClientWithEndpoint`. This constructor is provided to improve testability of this class.
     *
     * @param networkClient A network client which will manage remote RPCs to Rippled.
     */
    constructor(networkClient) {
        this.networkClient = networkClient;
    }
    /**
     * Create a new DefaultXpringClient.
     *
     * The DefaultXpringClient will use gRPC to communicate with the given endpoint.
     *
     * @param grpcURL The URL of the gRPC instance to connect to.
     * @param forceWeb If `true`, then we will use the gRPC-Web client even when on Node. Defaults to false. This is mainly for testing and in the future will be removed when we have browser testing.
     */
    static defaultXpringClientWithEndpoint(grpcURL, forceWeb = false) {
        return utils_1.default() && !forceWeb
            ? new DefaultXpringClient(new grpc_network_client_1.default(grpcURL))
            : new DefaultXpringClient(new grpc_network_client_web_1.default(grpcURL));
    }
    /**
     * Retrieve the balance for the given address.
     *
     * @param address The X-Address to retrieve a balance for.
     * @returns A `BigInteger` representing the number of drops of XRP in the account.
     */
    async getBalance(address) {
        const classicAddress = xpring_common_js_1.Utils.decodeXAddress(address);
        if (!classicAddress) {
            return Promise.reject(new Error(XpringClientErrorMessages.xAddressRequired));
        }
        const account = this.networkClient.AccountAddress();
        account.setAddress(classicAddress.address);
        const request = this.networkClient.GetAccountInfoRequest();
        request.setAccount(account);
        const accountInfo = await this.networkClient.getAccountInfo(request);
        const accountData = accountInfo.getAccountData();
        if (!accountData) {
            throw new Error(XpringClientErrorMessages.malformedResponse);
        }
        const balance = accountData.getBalance();
        if (!balance) {
            throw new Error(XpringClientErrorMessages.malformedResponse);
        }
        return big_integer_1.default(balance.getDrops());
    }
    /**
     * Retrieve the transaction status for a given transaction hash.
     *
     * @param transactionHash The hash of the transaction.
     * @returns The status of the given transaction.
     */
    async getTransactionStatus(transactionHash) {
        const transactionStatus = await this.getRawTransactionStatus(transactionHash);
        // Return pending if the transaction is not validated.
        if (!transactionStatus.getValidated()) {
            return transaction_status_1.default.Pending;
        }
        return transactionStatus.getTransactionStatusCode().startsWith('tes')
            ? transaction_status_1.default.Succeeded
            : transaction_status_1.default.Failed;
    }
    /**
     * Send the given amount of XRP from the source wallet to the destination address.
     *
     * @param drops A `BigInteger`, number or numeric string representing the number of drops to send.
     * @param destination A destination address to send the drops to.
     * @param sender The wallet that XRP will be sent from and which will sign the request.
     * @returns A promise which resolves to a string representing the hash of the submitted transaction.
     */
    async send(amount, destination, sender) {
        if (!xpring_common_js_1.Utils.isValidXAddress(destination)) {
            throw new Error(XpringClientErrorMessages.xAddressRequired);
        }
        const classicAddress = xpring_common_js_1.Utils.decodeXAddress(sender.getAddress());
        if (!classicAddress) {
            throw new Error(XpringClientErrorMessages.xAddressRequired);
        }
        const normalizedAmount = big_integer_1.default(amount.toString());
        const fee = await this.getMinimumFee();
        const accountData = await this.getAccountData(classicAddress.address);
        const lastValidatedLedgerSequence = await this.getLastValidatedLedgerSequence();
        const xrpDropsAmount = new amount_pb_1.XRPDropsAmount();
        xrpDropsAmount.setDrops(normalizedAmount.toJSNumber());
        const currencyAmount = new amount_pb_1.CurrencyAmount();
        currencyAmount.setXrpAmount(xrpDropsAmount);
        const destinationAccount = new amount_pb_1.AccountAddress();
        destinationAccount.setAddress(destination);
        const payment = new transaction_pb_1.Payment();
        payment.setDestination(destinationAccount);
        payment.setAmount(currencyAmount);
        const account = new amount_pb_1.AccountAddress();
        account.setAddress(sender.getAddress());
        const transaction = new transaction_pb_1.Transaction();
        transaction.setAccount(account);
        transaction.setFee(fee);
        transaction.setSequence(accountData.getSequence());
        transaction.setPayment(payment);
        transaction.setLastLedgerSequence(lastValidatedLedgerSequence + maxLedgerVersionOffset);
        const signingPublicKeyBytes = xpring_common_js_1.Utils.toBytes(sender.getPublicKey());
        transaction.setSigningPublicKey(signingPublicKeyBytes);
        const signedTransaction = xpring_common_js_1.Signer.signTransaction(transaction, sender);
        if (!signedTransaction) {
            throw new Error(XpringClientErrorMessages.malformedResponse);
        }
        const submitTransactionRequest = this.networkClient.SubmitTransactionRequest();
        submitTransactionRequest.setSignedTransaction(signedTransaction);
        const response = await this.networkClient.submitTransaction(submitTransactionRequest);
        return xpring_common_js_1.Utils.toHex(response.getHash_asU8());
    }
    async getLastValidatedLedgerSequence() {
        const getFeeResponse = await this.getFee();
        return getFeeResponse.getLedgerCurrentIndex();
    }
    async getRawTransactionStatus(transactionHash) {
        const getTxRequest = this.networkClient.GetTxRequest();
        getTxRequest.setHash(xpring_common_js_1.Utils.toBytes(transactionHash));
        const getTxResponse = await this.networkClient.getTx(getTxRequest);
        return new GetTxResponseWrapper(getTxResponse);
    }
    // TODO Keefer implement method and remove tslint ignore and fix tsconfig nounusedlocals
    // tslint:disable-next-line
    async getMinimumFee() {
        const getFeeResponse = await this.getFee();
        const fee = getFeeResponse.getDrops();
        if (!fee) {
            throw new Error(XpringClientErrorMessages.malformedResponse);
        }
        const minimumFee = fee.getMinimumFee();
        if (!minimumFee) {
            throw new Error(XpringClientErrorMessages.malformedResponse);
        }
        return minimumFee;
    }
    // TODO(keefertaylor): Add tests for this method once send is hooked up.
    async getFee() {
        const getFeeRequest = this.networkClient.GetFeeRequest();
        return this.networkClient.getFee(getFeeRequest);
    }
    async getAccountData(address) {
        const account = this.networkClient.AccountAddress();
        account.setAddress(address);
        const request = this.networkClient.GetAccountInfoRequest();
        request.setAccount(account);
        const accountInfo = await this.networkClient.getAccountInfo(request);
        if (!accountInfo) {
            throw new Error(XpringClientErrorMessages.malformedResponse);
        }
        const accountData = accountInfo.getAccountData();
        if (!accountData) {
            throw new Error(XpringClientErrorMessages.malformedResponse);
        }
        return accountData;
    }
}
exports.default = DefaultXpringClient;
//# sourceMappingURL=default-xpring-client.js.map