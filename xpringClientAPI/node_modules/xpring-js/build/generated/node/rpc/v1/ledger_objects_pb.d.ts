// package: rpc.v1
// file: rpc/v1/ledger_objects.proto

/* tslint:disable */
/* eslint-disable */

import * as jspb from "google-protobuf";
import * as rpc_v1_amount_pb from "../../rpc/v1/amount_pb";

export class LedgerObject extends jspb.Message { 

    hasAccountRoot(): boolean;
    clearAccountRoot(): void;
    getAccountRoot(): AccountRoot | undefined;
    setAccountRoot(value?: AccountRoot): void;


    hasRippleState(): boolean;
    clearRippleState(): void;
    getRippleState(): RippleState | undefined;
    setRippleState(value?: RippleState): void;


    hasOffer(): boolean;
    clearOffer(): void;
    getOffer(): Offer | undefined;
    setOffer(value?: Offer): void;


    hasSignerList(): boolean;
    clearSignerList(): void;
    getSignerList(): SignerList | undefined;
    setSignerList(value?: SignerList): void;


    hasDirectoryNode(): boolean;
    clearDirectoryNode(): void;
    getDirectoryNode(): DirectoryNode | undefined;
    setDirectoryNode(value?: DirectoryNode): void;


    getObjectCase(): LedgerObject.ObjectCase;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): LedgerObject.AsObject;
    static toObject(includeInstance: boolean, msg: LedgerObject): LedgerObject.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: LedgerObject, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): LedgerObject;
    static deserializeBinaryFromReader(message: LedgerObject, reader: jspb.BinaryReader): LedgerObject;
}

export namespace LedgerObject {
    export type AsObject = {
        accountRoot?: AccountRoot.AsObject,
        rippleState?: RippleState.AsObject,
        offer?: Offer.AsObject,
        signerList?: SignerList.AsObject,
        directoryNode?: DirectoryNode.AsObject,
    }

    export enum ObjectCase {
        OBJECT_NOT_SET = 0,
    
    ACCOUNT_ROOT = 1,

    RIPPLE_STATE = 2,

    OFFER = 3,

    SIGNER_LIST = 4,

    DIRECTORY_NODE = 5,

    }

}

export class DirectoryNode extends jspb.Message { 
    getFlags(): number;
    setFlags(value: number): void;

    getRootIndex(): Uint8Array | string;
    getRootIndex_asU8(): Uint8Array;
    getRootIndex_asB64(): string;
    setRootIndex(value: Uint8Array | string): void;

    clearIndexesList(): void;
    getIndexesList(): Array<Uint8Array | string>;
    getIndexesList_asU8(): Array<Uint8Array>;
    getIndexesList_asB64(): Array<string>;
    setIndexesList(value: Array<Uint8Array | string>): void;
    addIndexes(value: Uint8Array | string, index?: number): Uint8Array | string;

    getIndexNext(): number;
    setIndexNext(value: number): void;

    getIndexPrevious(): number;
    setIndexPrevious(value: number): void;

    getOwner(): string;
    setOwner(value: string): void;


    hasTakerPaysCurrency(): boolean;
    clearTakerPaysCurrency(): void;
    getTakerPaysCurrency(): rpc_v1_amount_pb.Currency | undefined;
    setTakerPaysCurrency(value?: rpc_v1_amount_pb.Currency): void;

    getTakerPaysIssuer(): Uint8Array | string;
    getTakerPaysIssuer_asU8(): Uint8Array;
    getTakerPaysIssuer_asB64(): string;
    setTakerPaysIssuer(value: Uint8Array | string): void;


    hasTakerGetsCurrency(): boolean;
    clearTakerGetsCurrency(): void;
    getTakerGetsCurrency(): rpc_v1_amount_pb.Currency | undefined;
    setTakerGetsCurrency(value?: rpc_v1_amount_pb.Currency): void;

    getTakerGetsIssuer(): Uint8Array | string;
    getTakerGetsIssuer_asU8(): Uint8Array;
    getTakerGetsIssuer_asB64(): string;
    setTakerGetsIssuer(value: Uint8Array | string): void;


    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): DirectoryNode.AsObject;
    static toObject(includeInstance: boolean, msg: DirectoryNode): DirectoryNode.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: DirectoryNode, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): DirectoryNode;
    static deserializeBinaryFromReader(message: DirectoryNode, reader: jspb.BinaryReader): DirectoryNode;
}

export namespace DirectoryNode {
    export type AsObject = {
        flags: number,
        rootIndex: Uint8Array | string,
        indexesList: Array<Uint8Array | string>,
        indexNext: number,
        indexPrevious: number,
        owner: string,
        takerPaysCurrency?: rpc_v1_amount_pb.Currency.AsObject,
        takerPaysIssuer: Uint8Array | string,
        takerGetsCurrency?: rpc_v1_amount_pb.Currency.AsObject,
        takerGetsIssuer: Uint8Array | string,
    }
}

export class SignerList extends jspb.Message { 
    getFlags(): number;
    setFlags(value: number): void;

    getPreviousTxnId(): Uint8Array | string;
    getPreviousTxnId_asU8(): Uint8Array;
    getPreviousTxnId_asB64(): string;
    setPreviousTxnId(value: Uint8Array | string): void;

    getPreviousTransactionLedgerSequence(): number;
    setPreviousTransactionLedgerSequence(value: number): void;

    getOwnerNode(): number;
    setOwnerNode(value: number): void;

    clearSignerEntriesList(): void;
    getSignerEntriesList(): Array<SignerEntry>;
    setSignerEntriesList(value: Array<SignerEntry>): void;
    addSignerEntries(value?: SignerEntry, index?: number): SignerEntry;

    getSignerListId(): number;
    setSignerListId(value: number): void;

    getSignerQuorum(): number;
    setSignerQuorum(value: number): void;


    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): SignerList.AsObject;
    static toObject(includeInstance: boolean, msg: SignerList): SignerList.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: SignerList, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): SignerList;
    static deserializeBinaryFromReader(message: SignerList, reader: jspb.BinaryReader): SignerList;
}

export namespace SignerList {
    export type AsObject = {
        flags: number,
        previousTxnId: Uint8Array | string,
        previousTransactionLedgerSequence: number,
        ownerNode: number,
        signerEntriesList: Array<SignerEntry.AsObject>,
        signerListId: number,
        signerQuorum: number,
    }
}

export class SignerEntry extends jspb.Message { 

    hasAccount(): boolean;
    clearAccount(): void;
    getAccount(): rpc_v1_amount_pb.AccountAddress | undefined;
    setAccount(value?: rpc_v1_amount_pb.AccountAddress): void;

    getSignerWeight(): number;
    setSignerWeight(value: number): void;


    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): SignerEntry.AsObject;
    static toObject(includeInstance: boolean, msg: SignerEntry): SignerEntry.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: SignerEntry, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): SignerEntry;
    static deserializeBinaryFromReader(message: SignerEntry, reader: jspb.BinaryReader): SignerEntry;
}

export namespace SignerEntry {
    export type AsObject = {
        account?: rpc_v1_amount_pb.AccountAddress.AsObject,
        signerWeight: number,
    }
}

export class AccountRoot extends jspb.Message { 

    hasAccount(): boolean;
    clearAccount(): void;
    getAccount(): rpc_v1_amount_pb.AccountAddress | undefined;
    setAccount(value?: rpc_v1_amount_pb.AccountAddress): void;


    hasBalance(): boolean;
    clearBalance(): void;
    getBalance(): rpc_v1_amount_pb.XRPDropsAmount | undefined;
    setBalance(value?: rpc_v1_amount_pb.XRPDropsAmount): void;

    getSequence(): number;
    setSequence(value: number): void;

    getFlags(): number;
    setFlags(value: number): void;

    getOwnerCount(): number;
    setOwnerCount(value: number): void;

    getPreviousTransactionId(): Uint8Array | string;
    getPreviousTransactionId_asU8(): Uint8Array;
    getPreviousTransactionId_asB64(): string;
    setPreviousTransactionId(value: Uint8Array | string): void;

    getPreviousTransactionLedgerSequence(): number;
    setPreviousTransactionLedgerSequence(value: number): void;

    getAccountTransactionId(): Uint8Array | string;
    getAccountTransactionId_asU8(): Uint8Array;
    getAccountTransactionId_asB64(): string;
    setAccountTransactionId(value: Uint8Array | string): void;

    getDomain(): Uint8Array | string;
    getDomain_asU8(): Uint8Array;
    getDomain_asB64(): string;
    setDomain(value: Uint8Array | string): void;

    getEmailHash(): Uint8Array | string;
    getEmailHash_asU8(): Uint8Array;
    getEmailHash_asB64(): string;
    setEmailHash(value: Uint8Array | string): void;

    getMessageKey(): Uint8Array | string;
    getMessageKey_asU8(): Uint8Array;
    getMessageKey_asB64(): string;
    setMessageKey(value: Uint8Array | string): void;

    getRegularKey(): string;
    setRegularKey(value: string): void;

    getTickSize(): number;
    setTickSize(value: number): void;

    getTransferRate(): number;
    setTransferRate(value: number): void;


    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): AccountRoot.AsObject;
    static toObject(includeInstance: boolean, msg: AccountRoot): AccountRoot.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: AccountRoot, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): AccountRoot;
    static deserializeBinaryFromReader(message: AccountRoot, reader: jspb.BinaryReader): AccountRoot;
}

export namespace AccountRoot {
    export type AsObject = {
        account?: rpc_v1_amount_pb.AccountAddress.AsObject,
        balance?: rpc_v1_amount_pb.XRPDropsAmount.AsObject,
        sequence: number,
        flags: number,
        ownerCount: number,
        previousTransactionId: Uint8Array | string,
        previousTransactionLedgerSequence: number,
        accountTransactionId: Uint8Array | string,
        domain: Uint8Array | string,
        emailHash: Uint8Array | string,
        messageKey: Uint8Array | string,
        regularKey: string,
        tickSize: number,
        transferRate: number,
    }
}

export class RippleState extends jspb.Message { 

    hasBalance(): boolean;
    clearBalance(): void;
    getBalance(): rpc_v1_amount_pb.CurrencyAmount | undefined;
    setBalance(value?: rpc_v1_amount_pb.CurrencyAmount): void;

    getFlags(): number;
    setFlags(value: number): void;


    hasLowLimit(): boolean;
    clearLowLimit(): void;
    getLowLimit(): rpc_v1_amount_pb.CurrencyAmount | undefined;
    setLowLimit(value?: rpc_v1_amount_pb.CurrencyAmount): void;


    hasHighLimit(): boolean;
    clearHighLimit(): void;
    getHighLimit(): rpc_v1_amount_pb.CurrencyAmount | undefined;
    setHighLimit(value?: rpc_v1_amount_pb.CurrencyAmount): void;

    getLowNode(): number;
    setLowNode(value: number): void;

    getHighNode(): number;
    setHighNode(value: number): void;

    getLowQualityIn(): number;
    setLowQualityIn(value: number): void;

    getLowQualityOut(): number;
    setLowQualityOut(value: number): void;

    getHighQualityIn(): number;
    setHighQualityIn(value: number): void;

    getHighQualityOut(): number;
    setHighQualityOut(value: number): void;

    getPreviousTransactionId(): Uint8Array | string;
    getPreviousTransactionId_asU8(): Uint8Array;
    getPreviousTransactionId_asB64(): string;
    setPreviousTransactionId(value: Uint8Array | string): void;

    getPreviousTransactionLedgerSequence(): number;
    setPreviousTransactionLedgerSequence(value: number): void;


    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): RippleState.AsObject;
    static toObject(includeInstance: boolean, msg: RippleState): RippleState.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: RippleState, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): RippleState;
    static deserializeBinaryFromReader(message: RippleState, reader: jspb.BinaryReader): RippleState;
}

export namespace RippleState {
    export type AsObject = {
        balance?: rpc_v1_amount_pb.CurrencyAmount.AsObject,
        flags: number,
        lowLimit?: rpc_v1_amount_pb.CurrencyAmount.AsObject,
        highLimit?: rpc_v1_amount_pb.CurrencyAmount.AsObject,
        lowNode: number,
        highNode: number,
        lowQualityIn: number,
        lowQualityOut: number,
        highQualityIn: number,
        highQualityOut: number,
        previousTransactionId: Uint8Array | string,
        previousTransactionLedgerSequence: number,
    }
}

export class Offer extends jspb.Message { 
    getAccount(): string;
    setAccount(value: string): void;

    getSequence(): number;
    setSequence(value: number): void;

    getFlags(): number;
    setFlags(value: number): void;


    hasTakerPays(): boolean;
    clearTakerPays(): void;
    getTakerPays(): rpc_v1_amount_pb.CurrencyAmount | undefined;
    setTakerPays(value?: rpc_v1_amount_pb.CurrencyAmount): void;


    hasTakerGets(): boolean;
    clearTakerGets(): void;
    getTakerGets(): rpc_v1_amount_pb.CurrencyAmount | undefined;
    setTakerGets(value?: rpc_v1_amount_pb.CurrencyAmount): void;

    getBookDirectory(): Uint8Array | string;
    getBookDirectory_asU8(): Uint8Array;
    getBookDirectory_asB64(): string;
    setBookDirectory(value: Uint8Array | string): void;

    getBookNode(): number;
    setBookNode(value: number): void;

    getOwnerNode(): number;
    setOwnerNode(value: number): void;

    getExpiration(): number;
    setExpiration(value: number): void;

    getPreviousTransactionId(): Uint8Array | string;
    getPreviousTransactionId_asU8(): Uint8Array;
    getPreviousTransactionId_asB64(): string;
    setPreviousTransactionId(value: Uint8Array | string): void;

    getPreviousTransactionLedgerSequence(): number;
    setPreviousTransactionLedgerSequence(value: number): void;


    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): Offer.AsObject;
    static toObject(includeInstance: boolean, msg: Offer): Offer.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: Offer, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): Offer;
    static deserializeBinaryFromReader(message: Offer, reader: jspb.BinaryReader): Offer;
}

export namespace Offer {
    export type AsObject = {
        account: string,
        sequence: number,
        flags: number,
        takerPays?: rpc_v1_amount_pb.CurrencyAmount.AsObject,
        takerGets?: rpc_v1_amount_pb.CurrencyAmount.AsObject,
        bookDirectory: Uint8Array | string,
        bookNode: number,
        ownerNode: number,
        expiration: number,
        previousTransactionId: Uint8Array | string,
        previousTransactionLedgerSequence: number,
    }
}

export enum LedgerEntryType {
    LEDGER_ENTRY_TYPE_UNSPECIFIED = 0,
    LEDGER_ENTRY_TYPE_ACCOUNT_ROOT = 1,
    LEDGER_ENTRY_TYPE_AMENDMENTS = 2,
    LEDGER_ENTRY_TYPE_CHECK = 3,
    LEDGER_ENTRY_TYPE_DEPOSIT_PREAUTH = 4,
    LEDGER_ENTRY_TYPE_DIRECTORY_NODE = 5,
    LEDGER_ENTRY_TYPE_ESCROW = 6,
    LEDGER_ENTRY_TYPE_FEE_SETTINGS = 7,
    LEDGER_ENTRY_TYPE_LEDGER_HASHES = 8,
    LEDGER_ENTRY_TYPE_OFFER = 9,
    LEDGER_ENTRY_TYPE_PAY_CHANNEL = 10,
    LEDGER_ENTRY_TYPE_RIPPLE_STATE = 11,
    LEDGER_ENTRY_TYPE_SIGNER_LIST = 12,
}
